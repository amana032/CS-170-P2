import random

# Read in data set and parse as tuples (class, feature 1, feature 2, etc.)
f = open('CS170_Small_Data__41.txt', "r")
data = []
for line in f:
     object_to_tuple = tuple(map(float, line.split()))
     data.append(object_to_tuple)
f.close()

def leave_one_out_cross_validation(data, current_set, feature_to_add):
    return random.random() # To be replaced with actual implementation

def feature_search(data):
    best_set_per_level = [] # Keeps track of the best feature set per level, list of tuples (level, feature set, total accuracy)
    best_feature_set_total = (None, None, 0) # The best feature set overall, to be returned
    current_set = [] # The current set of features, starts empty
    
    for i in range(1, len(data[0])):
        best_accuracy = 0
        feature_to_add_this_level = -1
        
        print(f"On Level {i} of the search tree")
        
        for k in range(1, len(data[0])): # For each feature, check if it improves accuracy from the previous level set
            if k not in current_set: # Has this feature been added yet? Skip if so
                print(f" - Considering adding feature {k}:")
                accuracy = leave_one_out_cross_validation(data, current_set, k) # Grab the accuracy of the feature set with this feature added
                print(f"   - Accuracy: {accuracy}")

                if accuracy > best_accuracy: # Is this feature better than the best feature so far? Add if so
                    best_accuracy = accuracy
                    feature_to_add_this_level = k
        
        # Parsed through all the features! Did we find a one that improved accuracy?
        if feature_to_add_this_level == -1: # No features improved accuracy
            print(f"No features improve accuracy; exiting level {i}")

        else:
            current_set.append(feature_to_add_this_level) # Add the best feature to the current set
            tuple = (i, current_set.copy(), best_accuracy)
            best_set_per_level.append(tuple) # Keep a copy of this level in case it's the best
            print(f"Added feature {feature_to_add_this_level} on level {i} with accuracy {best_accuracy}")

    # Print the best feature set at each level
    for i in best_set_per_level:
        print('Level', i[0], 'Feature set:', i[1], ', Accuracy:', i[2])
        if i[2] > best_feature_set_total[2]: # Is this the best feature set so far? Update if so
            best_feature_set_total = i
    
    print(f"Best feature set: {best_feature_set_total[1]} with accuracy {best_feature_set_total[2]}")
    return best_feature_set_total # Best feature set and accuracy found!


def main():
    feature_search(data)

# __name__
if __name__=="__main__":
    main()
